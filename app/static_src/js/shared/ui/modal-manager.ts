import { makeToast } from './toast.js';
import { apiRequest } from '../services/api.js';
import { FormDialog, FormControlElement } from '../../types';
import { formToJSON } from '../forms.js';
import { isoToTimeInput, isoToDateInput } from '../datetime.js';
import { formatDecimal } from '../numbers.js';
import { removeTableRow } from '../tables.js';

/**
 * Modal Manager
 * 
 * Auto-discovers & wires up form modals based on naming convention:
 * - Modal ID:  {subtype}-entry-{context}-modal     (e.g., 'daily_metrics-entry-dashboard-modal')
 * - Button ID: {subtype}-entry-{context}-btn       (e.g., 'daily_metrics-entry-dashboard-btn') 
 * - Close ID:  {subtype}-entry-{context}-close-btn (generated by macro)
 * 
 * Handles open/close, AJAX submission (POST/PUT), and state cleanup.
 */


/**
 * Scans for `<dialog>` elements with id ending in '-modal' and 
 * wires them up with matching '-btn' triggers.
 */
function initModals() {
    const modals = document.querySelectorAll('[id$="-modal"]');

    modals.forEach(modal => {
        if (!(modal instanceof HTMLDialogElement)) return;

        const fullId = modal.id; // "habit-entry-dashboard-modal"
        const baseId = fullId.replace('-modal', ''); // "habit-entry-dashboard"
        const button = document.querySelector<HTMLButtonElement>(`#${baseId}-btn`);

        if (button) {
            setupModal(modal, button);
        }

        if (modal.classList.contains('tabbed-modal') || modal.querySelector('.tab-group')) {
            setupTabbedModal(modal);
        }
    });
}

/**
 * Wires up a form modal with open/close/submit behavior.
 * 
 * Expects:
 * - Modal has `data-endpoint` for API URL
 * - Close button matches `#${modalId}-close-btn`
 * - Edit mode indicated by `data-mode="edit"` + `data-item-id`
 */
function setupModal(modal: FormDialog, button: HTMLButtonElement): void {
    const form = modal.querySelector('form');
    const modalId = modal.id;
    if (!form) {
        console.warn(`Modal ${modalId} has no form element`)
        return;
    }

    button.addEventListener('click', () => {
        modal.showModal();
    })

    modal.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        if (target.matches(`#${modalId}-close-btn`)) {
            modal.close();
        }
    });

    /**
     * Restores modal state so it can be re-invoked:
     * - Resets form values
     * - Clears edit-mode dataset attributes
     * - Reverts `disabled` states of fields to initial values `data-initial-disabled`
     */
    modal.addEventListener('close', () => {
        form.reset();
        delete modal.dataset.mode;
        delete modal.dataset.itemId;

        // trying custom event
        // dispatch BEFORE doing cleanup so listeners can save state if needed?
        modal.dispatchEvent(new CustomEvent('modal:cleanup'));

        // Revert fields to their original disabled states
        // for all initialDisabled => disable
        // for all now disabled without initialDisabled => re-enable them
        const formEls = modal.querySelectorAll<FormControlElement>('input, textarea, select');

        formEls.forEach((el) => {
            el.disabled = el.dataset['initialDisabled'] !== undefined;

            // Wipe invalid states
            el.classList.remove('invalid');
        });

        // Wipe all error messages
        const smallEls = modal.querySelectorAll('small');
        smallEls.forEach(el => {
            el.textContent = '';
        })

        const productHidden = modal.querySelector<HTMLInputElement>('#product_id_hidden');
        if (productHidden) {
            productHidden.value = "";
        }
        // Restore product_id product list for Transaction form modal
        const productSelect = modal.querySelector<HTMLSelectElement>('#product_id');
        if (productSelect?.dataset['originalInnerHTML']) {
            productSelect.innerHTML = productSelect.dataset['originalInnerHTML'];
            delete productSelect.dataset['originalInnerHTML'];
        }
    });
}

export function handleModalFormSubmit(submittedForm: HTMLFormElement, modal: HTMLDialogElement) {
    const formData = formToJSON(submittedForm);
    const endpoint = modal.dataset.endpoint; // embedded in all form modals

    if (!endpoint) {
        throw new Error('FormDialog modal missing data-endpoint attribute');
    }

    // PUT
    if (modal.dataset.mode === 'edit') {
        const url = `${endpoint}/${modal.dataset.itemId}`;
        apiRequest('PUT', url, formData, {
            onSuccess: (responseData) => {
                makeToast(responseData.message, 'success');
            },
            onFailure: (responseData) => {
                makeToast(responseData.message, 'error');
            }
        });
    }
    // POST
    else {
        apiRequest('POST', endpoint, formData, {
            onSuccess: (responseData) => {
                makeToast(responseData.message, 'success');
            },
            onFailure: (responseData) => {
                makeToast(responseData.message, 'error')
            }
        });
    }
    submittedForm.reset();
    modal.close();
}

/**
 * Sets up a modal with tab switching enabled.
 * 
 * Expects:
 * - Buttons with `.tab-group button` and `data-tab="{name}"`
 * - Panels with `.tab-content` and `id="tab-{name}"`
 * 
 * Auto-activates the first tab on setup.
 */
function setupTabbedModal(modal: FormDialog): void {
    const tabGroupBtns = modal.querySelectorAll<HTMLButtonElement>('.tab-group button');

    tabGroupBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // hide all panels & remove active
            modal.querySelectorAll<HTMLButtonElement>('.tab-group button').forEach(b => b.classList.remove('active'));
            modal.querySelectorAll<HTMLElement>('.tab-content').forEach(p => p.hidden = true);
            // show selected
            const tabId = 'tab-' + btn.dataset['tab'];
            const panel = modal.querySelector<HTMLElement>(`#${tabId}`);
            if (panel) {
                btn.classList.add('active');
                panel.hidden = false;
            };
        });
    });
    const firstTab = modal.querySelector<HTMLButtonElement>('.tab-group button');
    firstTab?.click();
}

/**
 * Opens a form modal in edit mode & populates fields with data from backend via API.
 * 
 * Side effects:
 * - Sets modal `data-mode="edit"` to route form submission to PATCH
 * - Populates form inputs based on API response.
 * TODO: Check/clarify below:
 * - For `transactions`, disables the `select#product_id` and mirrors
 * its value into `input#product_id_hidden` to preserve submission.
 * The disabled field is tagged with `data-disabled-overriden` and must be reverted
 * upon modal close.
 * 
 * @param itemId - ID of the item to edit
 * @param url - API endpoint to fetch item data (e.g., `/groceries/products/123`)
 * @param modal - The modal element to populate
 * @param itemLabel - Human-readable label for legend (e.g., "Product", "Task")
 */
export function openModalForEdit(
    itemId: string,
    url: string,       // caller builds url
    modal: FormDialog, // caller finds modal
    itemLabel: string, // for legend text: "Edit Product", etc
): void {
    apiRequest('GET', url, null, {
        onSuccess: (responseData) => {
            modal.dataset.mode = 'edit';
            modal.dataset.itemId = itemId;
            // modal.dataset.subtype = subtype; does it break without this?
            modal.showModal();
            populateModalFields(modal, responseData.data);

            const legend = modal.querySelector('legend');

            modal.addEventListener('modal:cleanup', () => {
                if (legend?.dataset.originalText) {
                    legend.textContent = legend.dataset.originalText;
                    delete legend.dataset['originalText'];
                }
            }, { once: true });

            if (legend) {
                legend.dataset.originalText = legend.textContent;
                legend.textContent = `Edit ${itemLabel}`;
            }

            // Transaction form-specific hack: Not ideal, but probably the clearest option for now
            if (modal.id === 'transactions-entry-dashboard-modal') {
                const productSelectInput = modal.querySelector<HTMLSelectElement>('#product_id');
                const productInputHidden = modal.querySelector<HTMLInputElement>('#product_id_hidden');
                if (productSelectInput && productInputHidden) {
                    productSelectInput.dataset['originalInnerHTML'] = productSelectInput.innerHTML;
                    productSelectInput.innerHTML = `<option selected>${responseData.data.product_name}</option>`;

                    productSelectInput.disabled = true;
                    productInputHidden.value = responseData.data.product_id;
                    productInputHidden.disabled = false; // enable for edit, starts out disabled
                }
            }
        }
    })
}

/**
 * Deletes an item via API after user confirmation.
 * 
 * Shows confirmation dialog, then sends DELETE request.
 * Displays success toast but does NOT remove UI elements.
 * 
 * @param itemId - ID of item to delete (used in toast message)
 * @param url - DELETE endpoint (eg, `tasks/tasks/123`)
 */
export async function handleDelete(
    itemId: string,
    url: string,
) {
    const confirmed = await confirmationManager.show("You sure you wanna delete?");
    if (!confirmed) return;

    apiRequest('DELETE', url, null, {
        onSuccess: () => {
            makeToast(`${itemId} deleted`, 'success');
            const itemRow = document.querySelector<HTMLTableRowElement>(`[data-item-id="${itemId}"]`);
            if (!itemRow) return;
            removeTableRow(itemRow);
        }
    })
}


/**
 * Populates form modal fields with data from API response.
 * Matches field names to input element IDs and handles type-specific formatting
 * (dates, times, checkboxes, selects, etc)
 * 
 * @remarks
 * Relies on backend field names aligning with frontend input IDs.
 */
function populateModalFields(modal: HTMLDialogElement, data: Record<string, any>) {
    Object.entries(data).forEach(([fieldName, fieldValue]) => {
        const input = modal.querySelector<HTMLInputElement>(`#${fieldName}`);
        if (!input || fieldValue === null) return;

        switch (input.type) {
            case 'checkbox':
                input.checked = fieldValue;
                break;
            case 'date':
                input.value = isoToDateInput(fieldValue);
                break;
            case 'time':
                input.value = isoToTimeInput(fieldValue);
                break;
            case 'select-one':
                if (typeof fieldValue === 'string') {
                    input.value = fieldValue.toLowerCase();
                } else {
                    input.value = fieldValue;
                }
                break;
            default:
                if (input.type === 'number') {
                    const step = parseFloat(input.step) || 1;
                    input.value = (step === 1)
                        ? String(Math.round(fieldValue))
                        : formatDecimal(fieldValue, 2);
                } else {
                    input.value = String(fieldValue);
                }
        }
    });
    // For time entries, derive entry_date from started_at
    if ('started_at' in data) {
        const entryDateInput = modal.querySelector<HTMLInputElement>('#entry_date');
        if (entryDateInput) {
            entryDateInput.value = isoToDateInput(data['started_at']);
        }
    }
}

/**
 * Singleton for managing confirmation dialogs.
 * 
 * Usage:
 *  confirmationManager.init(); // once on page load
 *  const confirmed = await confirmationManager.show('Delete this item?');
 *  if (confirmed) { ... }
 * 
 * Expects modal markup with:
 * - `#confirmation-modal` (dialog)
 * - `.confirmation-message` (text container)
 * - `#confirm-ok` / `#confirm-cancel` (buttons)
 */
export const confirmationManager: {
    currentResolve: ((value: boolean) => void) | null;
    modal: HTMLDialogElement | null;
    modalMsg: HTMLElement | null;
    init(): void;
    show(message: string): Promise<boolean>;
} = {
    currentResolve: null, // store active resolve function
    modal: null,
    modalMsg: null,

    init() {
        // one-time setup for confirmation modals
        const modal = document.querySelector('#confirmation-modal') as HTMLDialogElement;
        const modalMsg = document.querySelector('.confirmation-message') as HTMLElement;
        if (!modal || !modalMsg) {
            throw new Error('Confirmation modal / message element not found');
        }
        this.modal = modal;
        this.modalMsg = modalMsg;
        
        this.modal.addEventListener('click', (e) => {
            const target = e.target as HTMLElement;
            if (target.matches('#confirm-ok') && this.currentResolve) {
                this.currentResolve(true); // lets our await receive its answer
                this.modal!.close();
                this.currentResolve = null; // then clean it up
            }
            else if (target.matches('#confirm-cancel') && this.currentResolve) {
                this.currentResolve(false);
                this.modal!.close();
                this.currentResolve = null;
            }
        })
    },

    show(message: string): Promise<boolean> {
        return new Promise((resolve) => {
            this.modalMsg!.textContent = message;
            this.modal!.showModal();

            this.currentResolve = resolve; // store THIS promise's resolve
        });
    }
}

confirmationManager.init();
initModals();