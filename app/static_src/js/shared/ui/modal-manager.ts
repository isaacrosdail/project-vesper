import { makeToast } from './toast.js';
import { apiRequest } from '../services/api.js';
import { FormDialog } from '../../types';

/**
 * Modal Manager
 * 
 * Auto-discovers & wires up form modals based on naming convention:
 * - Modal ID:  {subtype}-entry-{context}-modal     (e.g., 'daily_metrics-entry-dashboard-modal')
 * - Button ID: {subtype}-entry-{context}-btn       (e.g., 'daily_metrics-entry-dashboard-btn') 
 * - Close ID:  {subtype}-entry-{context}-close-btn (generated by macro)
 * 
 * Handles open/close, AJAX submission (POST/PUT), and state cleanup.
 */


/**
 * Scans for `<dialog>` elements with id ending in '-modal' and 
 * wires them up with matching '-btn' triggers.
 */
function initModals() {
    const modals = document.querySelectorAll('[id$="-modal"]');

    modals.forEach(modal => {
        if (!(modal instanceof HTMLDialogElement)) return;

        const fullId = modal.id; // "habit-entry-dashboard-modal"
        const baseId = fullId.replace('-modal', ''); // "habit-entry-dashboard"
        const button = document.querySelector<HTMLButtonElement>(`#${baseId}-btn`);

        if (button) {
            setupModal(modal, button);
        }

        if (modal.classList.contains('tabbed-modal') || modal.querySelector('.tab-group')) {
            setupTabbedModal(modal);
        }
    });
}

/**
 * Wires up a form modal with open/close/submit behavior.
 * 
 * Expects:
 * - Modal has `data-endpoint` for API URL
 * - Close button matches `#${modalId}-close-btn`
 * - Edit mode indicated by `data-mode="edit"` + `data-item-id`
 */
function setupModal(modal: FormDialog, button: HTMLButtonElement): void {
    const form = modal.querySelector('form');
    const modalId = modal.id;
    if (!form) {
        console.warn(`Modal ${modalId} has no form element`)
        return;
    }

    button.addEventListener('click', () => {
        modal.showModal();
    })

    modal.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        if (target.matches(`#${modalId}-close-btn`)) {
            modal.close();
        }
    });

    /**
     * Restores modal state so it can be re-invoked:
     * - Resets form values
     * - Clears edit-mode dataset attributes
     * - Reverts `disabled` state of any fields marked with `data-initial-disabled`
     */
    modal.addEventListener('close', () => {
        form.reset();
        delete modal.dataset.mode;
        delete modal.dataset.itemId;

        // Clear disabled on fields which overrode it
        const initialDisabled = modal.querySelectorAll<HTMLInputElement | HTMLSelectElement>('[data-initial-disabled]');
        initialDisabled.forEach((el) => {
            el.disabled = (el.dataset['initialDisabled'] === 'true');
            el.removeAttribute('data-initial-disabled');
        });

        const legend = modal.querySelector('legend');
        if (legend && legend.dataset['originalText']) {
            legend.textContent = legend.dataset['originalText'];
            delete legend.dataset['originalText'];
        }

        const productHidden = modal.querySelector<HTMLInputElement>('#product_id_hidden');
        if (productHidden) {
            productHidden.value = "";
        }
        // Restore product_id product list for Transaction form modal
        const productSelect = modal.querySelector<HTMLSelectElement>('#product_id');
        if (productSelect?.dataset['originalInnerHTML']) {
            productSelect.innerHTML = productSelect.dataset['originalInnerHTML'];
            delete productSelect.dataset['originalInnerHTML'];
        }
    });

    modal.addEventListener('submit', async (e) => {
        const submittedForm = e.target as HTMLFormElement;
        if (submittedForm.hasAttribute('data-noajax')) {
            return;  // Skip interception if the form opts out
        }
        e.preventDefault();
        
        const formData = new FormData(submittedForm);
        const endpoint = modal.dataset.endpoint; // embedded dynamically in all form modals
        if (!endpoint) {
            throw new Error('FormDialog modal missing data-endpoint attribute');
        }
        
        // PUT
        if (modal.dataset.mode === 'edit') {
            const url = `${endpoint}/${modal.dataset.itemId}`;
            apiRequest('PUT', url, formData, {
                onSuccess: (responseData) => {
                    makeToast(responseData.message, 'success');
                },
                onFailure: (responseData) => {
                    makeToast(responseData.message, 'error');
                }
            });
        }
        // POST
        else {
            apiRequest('POST', endpoint, formData, {
                onSuccess: (responseData) => {
                    makeToast(responseData.message, 'success');
                },
                onFailure: (responseData) => {
                    makeToast(responseData.message, 'error')
                }
            });
        }
        submittedForm.reset();
        modal.close();
    });
}

/**
 * Sets up a modal with tab switching enabled.
 * 
 * Expects:
 * - Buttons with `.tab-group button` and `data-tab="{name}"`
 * - Panels with `.tab-content` and `id="tab-{name}"`
 * 
 * Auto-activates the first tab on setup.
 */
function setupTabbedModal(modal: FormDialog): void {
    const tabGroupBtns = modal.querySelectorAll<HTMLButtonElement>('.tab-group button');

    tabGroupBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // hide all panels & remove active
            modal.querySelectorAll<HTMLButtonElement>('.tab-group button').forEach(b => b.classList.remove('active'));
            modal.querySelectorAll<HTMLElement>('.tab-content').forEach(p => p.hidden = true);
            // show selected
            const tabId = 'tab-' + btn.dataset['tab'];
            const panel = modal.querySelector<HTMLElement>(`#${tabId}`);
            if (panel) {
                btn.classList.add('active');
                panel.hidden = false;
            };
        });
    });
    const firstTab = modal.querySelector<HTMLButtonElement>('.tab-group button');
    firstTab?.click();
}

/**
 * Singleton for managing confirmation dialogs.
 * 
 * Usage:
 *  confirmationManager.init(); // once on page load
 *  const confirmed = await confirmationManager.show('Delete this item?');
 *  if (confirmed) { ... }
 * 
 * Expects modal markup with:
 * - `#confirmation-modal` (dialog)
 * - `.confirmation-message` (text container)
 * - `#confirm-ok` / `#confirm-cancel` (buttons)
 */
export const confirmationManager: {
    currentResolve: ((value: boolean) => void) | null;
    modal: HTMLDialogElement | null;
    modalMsg: HTMLElement | null;
    init(): void;
    show(message: string): Promise<boolean>;
} = {
    currentResolve: null, // store active resolve function
    modal: null,
    modalMsg: null,

    init() {
        // one-time setup for confirmation modals
        const modal = document.querySelector('#confirmation-modal') as HTMLDialogElement;
        const modalMsg = document.querySelector('.confirmation-message') as HTMLElement;
        if (!modal || !modalMsg) {
            throw new Error('Confirmation modal / message element not found');
        }
        this.modal = modal;
        this.modalMsg = modalMsg;
        
        this.modal.addEventListener('click', (e) => {
            const target = e.target as HTMLElement;
            if (target.matches('#confirm-ok') && this.currentResolve) {
                this.currentResolve(true); // lets our await receive its answer
                this.modal!.close();
                this.currentResolve = null; // then clean it up
            }
            else if (target.matches('#confirm-cancel') && this.currentResolve) {
                this.currentResolve(false);
                this.modal!.close();
                this.currentResolve = null;
            }
        })
    },

    show(message: string): Promise<boolean> {
        return new Promise((resolve) => {
            this.modalMsg!.textContent = message;
            this.modal!.showModal();

            this.currentResolve = resolve; // store THIS promise's resolve
        });
    }
}

confirmationManager.init();
initModals();