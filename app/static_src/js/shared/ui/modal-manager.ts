import { makeToast } from './toast.js';
import { apiRequest } from '../services/api.js';
import { FormDialog } from '../../types';

/**
 * Modal Manager - Auto-discovers standardized modals
 * 
 * NAMING CONVENTION:
 * - Modal ID:  {subtype}-entry-{context}-modal     (e.g., 'daily_entries-entry-dashboard-modal')
 * - Button ID: {subtype}-entry-{context}-btn       (e.g., 'daily_entries-entry-dashboard-btn') 
 * - Close ID:  {subtype}-entry-{context}-close-btn (generated by macro)
 * 
 * USAGE:
 * 1. Use modal macro: {% call ui.modal('module', 'subtype', 'base-id', 'Title') %}
 *  - NOTE: module & subtype are both pluralized & snake_cased now for model-API parity
 * 2. Add matching button with ID: {base-id}-btn
 * 3. Then this'll auto-discover & wire up all modals on page load
 * 
 * - Derives button ID by replacing '-modal' with '-btn'
 * - Sets up open/close/submit handlers
 * - Gets endpoint from modal's data-endpoint attribute
 * - To opt out of special submit handling below (ie, for non-form-modal forms), simply add 'data-noajax' attribute to the form element itself
 */


// Scan for modals following our naming pattern
const modals = document.querySelectorAll('[id$="-modal"]');

modals.forEach(modal => {
    if (!(modal instanceof HTMLDialogElement)) return;

    const fullId = modal.id; // "habit-entry-dashboard-modal"
    const baseId = fullId.replace('-modal', ''); // "habit-entry-dashboard"
    const button = document.querySelector(`#${baseId}-btn`) as HTMLButtonElement;

    if (button) {
        setupModal(modal, button);
    }

    // Set up tabbed modal handling based on naming conventions
    if (modal.classList.contains('tabbed-modal') || modal.querySelector('.tab-group')) {
        setupTabbedModal(modal);
    }
});

function setupModal(modal: FormDialog, button: HTMLButtonElement): void {
    const form = modal.querySelector('form');
    const modalId = modal.id;
    if (!form) {
        console.warn(`Modal ${modalId} has no form element`)
        return;
    }

    button.addEventListener('click', () => {
        modal.showModal();
    })

    modal.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        if (target.matches(`#${modalId}-close-btn`)) {
            form.reset();
            modal.close();
        }
    })

    modal.addEventListener('cancel', () => {
        form.reset();
    });

    modal.addEventListener('submit', async (e) => {
        const submittedForm = e.target as HTMLFormElement;
        if (submittedForm.hasAttribute('data-noajax')) {
            return;  // Skip interception if the form opts out
        }
        e.preventDefault();
        
        const formData = new FormData(submittedForm);
        const endpoint = modal.dataset.endpoint; // embedded dynamically in all form modals
        if (!endpoint) {
            throw new Error('FormDialog modal missing data-endpoint attribute');
        }
        
        // PUT
        if (modal.dataset.mode === 'edit') {
            const url = `${endpoint}/${modal.dataset.itemId}`;
            apiRequest('PUT', url, (responseData) => {
                makeToast(responseData.message, 'success');
                // Clean up edit state
                delete modal.dataset.mode;
                delete modal.dataset.itemId;
            }, formData);
        }
        // POST
        else {
            apiRequest('POST', endpoint, (responseData) => { // get server response inside success callback
                makeToast(responseData.message, 'success');
            }, formData);
        }
        submittedForm.reset();
        modal.close();
    });
}

function setupTabbedModal(modal: FormDialog): void {
    modal.querySelectorAll<HTMLButtonElement>('.tab-group button').forEach(btn => {
        btn.addEventListener('click', () => {
            // hide all panels & remove active
            modal.querySelectorAll<HTMLButtonElement>('.tab-group button').forEach(b => b.classList.remove('active'));
            modal.querySelectorAll<HTMLElement>('.tab-content').forEach(p => p.hidden = true);
            // show selected
            const tabId = 'tab-' + btn.dataset['tab'];
            const panel = modal.querySelector(`#${tabId}`) as HTMLElement;
            if (panel) {
                btn.classList.add('active');
                panel.hidden = false;
            };
        });
    });

    // Auto-activate first tab
    const firstTab = modal.querySelector<HTMLButtonElement>('.tab-group button');
    firstTab?.click();
}

// Trying out a confirmation manager singleton for dynamically handling confirmation popups
export const confirmationManager: {
    currentResolve: ((value: boolean) => void) | null;
    modal: HTMLDialogElement | null;
    modalMsg: HTMLElement | null;
    init(): void;
    show(message: string): Promise<boolean>;
} = {
    currentResolve: null, // store active resolve function
    modal: null,
    modalMsg: null,

    init() {
        // one-time setup for confirmation modals
        const modal = document.querySelector('#confirmation-modal') as HTMLDialogElement;
        const modalMsg = document.querySelector('.confirmation-message') as HTMLElement;
        if (!modal || !modalMsg) {
            throw new Error('Confirmation modal / message element not found');
        }
        this.modal = modal;
        this.modalMsg = modalMsg;
        
        this.modal.addEventListener('click', (e) => {
            const target = e.target as HTMLElement;
            if (target.matches('#confirm-ok') && this.currentResolve) {
                this.currentResolve(true); // lets our await receive its answer
                this.modal!.close();
                this.currentResolve = null; // then clean it up quickly prior to subsequent calls
            }
            else if (target.matches('#confirm-cancel') && this.currentResolve) {
                this.currentResolve(false);
                this.modal!.close();
                this.currentResolve = null;
            }
        })
    },

    show(message: string): Promise<boolean> {
        return new Promise((resolve) => {
            this.modalMsg!.textContent = message;
            this.modal!.showModal();

            this.currentResolve = resolve; // store THIS promise's resolve
        });
    }
}

// Set up listeners once
confirmationManager.init();