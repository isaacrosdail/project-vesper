import { makeToast } from './toast.js';
import { makeTableRow} from '../tables.js';
import { apiRequest } from '../services/api.js';

/**
 * Modal Manager - Auto-discovers standardized modals
 * 
 * NAMING CONVENTION:
 * - Modal ID:  {subtype}-entry-{context}-modal     (e.g., 'daily_entries-entry-dashboard-modal')
 * - Button ID: {subtype}-entry-{context}-btn       (e.g., 'daily_entries-entry-dashboard-btn') 
 * - Close ID:  {subtype}-entry-{context}-close-btn (generated by macro)
 * 
 * USAGE:
 * 1. Use modal macro: {% call ui.modal('module', 'subtype', 'base-id', 'Title') %}
 *  - NOTE: module & subtype are both pluralized & snake_cased now for model-API parity
 * 2. Add matching button with ID: {base-id}-btn
 * 3. Then this'll auto-discover & wire up all modals on page load
 * 
 * - Derives button ID by replacing '-modal' with '-btn'
 * - Sets up open/close/submit handlers
 * - Gets endpoint from modal's data-endpoint attribute
 * - To opt out of special submit handling below (ie, for non-form-modal forms), simply add 'data-noajax' attribute to the form element itself
 */


// Scan for modals following our naming pattern
const modals = document.querySelectorAll('[id$="-modal"]'); // $= means "ends with"

modals.forEach(modal => {
    const fullId = modal.id; // "habit-entry-dashboard-modal"
    const baseId = fullId.replace('-modal', ''); // "habit-entry-dashboard"
    const button = document.querySelector(`#${baseId}-btn`);

    if (button) {
        setupModal(modal, button);
    }

    // Set up tabbed modal handling based on naming conventions
    if (modal.classList.contains('tabbed-modal') || modal.querySelector('.tab-group')) {
        setupTabbedModal(modal);
    }
});

function setupModal(modal, button) {
    const form = modal.querySelector('form');
    const modalId = modal.id;

    button.addEventListener('click', () => {
        modal.showModal();
    })

    modal.addEventListener('click', (e) => {
        if (e.target.matches(`#${modalId}-close-btn`)) {
            form?.reset();
            modal.close();
        }
    })

    modal.addEventListener('cancel', () => {
        form?.reset();
    });

    modal.addEventListener('submit', async (e) => {
        const submittedForm = e.target;
        if (submittedForm.hasAttribute('data-noajax')) {
            return;  // Skip interception if the form opts out
        }

        e.preventDefault();
        const formData = new FormData(submittedForm);
        const endpoint = modal.dataset.endpoint; // embedded dynamically in all form modals
        
        // PUT
        if (modal.dataset.mode === 'edit') {
            const url = `${endpoint}/${modal.dataset.itemId}`;
            apiRequest('PUT', url, (responseData) => {
                makeToast(responseData.message, 'success');
                // Clean up edit state
                delete modal.dataset.mode;
                delete modal.dataset.itemId;
            }, formData);
        }
        // POST
        else {
            apiRequest('POST', endpoint, (responseData) => { // get server response inside success callback
                makeToast(responseData.message, 'success');
            }, formData);
        }
        submittedForm.reset();
        modal.close();
    });
}

function setupTabbedModal(modal) {
    modal.querySelectorAll('.tab-group button').forEach(btn => {
        btn.addEventListener('click', () => {
            // hide all panels & remove active
            modal.querySelectorAll('.tab-group button').forEach(b => b.classList.remove('active'));
            modal.querySelectorAll('.tab-content').forEach(p => p.hidden = true);
            // show selected
            const tabId = 'tab-' + btn.dataset.tab;
            const panel = modal.querySelector(`#${tabId}`);
            if (panel) {
                btn.classList.add('active');
                panel.hidden = false;
            };
        });
    });

    // Auto-activate first tab
    const firstTab = modal.querySelector('.tab-group button');
    firstTab?.click();
}

// Trying out a confirmation manager singleton for dynamically handling confirmation popups
// TODO: Practice/study further
export const confirmationManager = {
    currentResolve: null, // store active resolve function

    init() {
        // one-time setup for confirmation modals
        const modal = document.querySelector('#confirmation-modal');
        modal?.addEventListener('click', (e) => {
            if (e.target.matches('#confirm-ok') && this.currentResolve) {
                this.currentResolve(true); // lets our await receive its answer
                modal.close();
                this.currentResolve = null; // then clean it up quickly prior to subsequent calls
            }
            else if (e.target.matches('#confirm-cancel') && this.currentResolve) {
                this.currentResolve(false);
                modal.close();
                this.currentResolve = null;
            }
        })
    },

    show(message) {
        return new Promise((resolve) => {
            // 1. update modal text (cls: confirmation-message) with message
            const confirmationMsg = document.querySelector('.confirmation-message');
            confirmationMsg.textContent = message;

            // 2. Show the modal
            const modal = document.querySelector('#confirmation-modal');
            modal?.showModal();

            this.currentResolve = resolve; // store THIS promise's resolve
        });
    }
}

// Set up listeners once
confirmationManager.init();