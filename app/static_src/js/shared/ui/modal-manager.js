import { makeToast } from './toast.js';
import { makeTableRow} from '../tables.js';
import { apiRequest } from '../services/api.js';

/**
 * Modal Manager - Auto-discovers standardized modals
 * 
 * NAMING CONVENTION:
 * - Modal ID:  {type}-entry-{context}-modal     (e.g., 'task-entry-dashboard-modal')
 * - Button ID: {type}-entry-{context}-btn       (e.g., 'task-entry-dashboard-btn') 
 * - Close ID:  {type}-entry-{context}-close-btn (generated by macro)
 * 
 * USAGE:
 * 1. Use modal macro: {% call ui.modal('endpoint', 'base-id', 'Title') %}
 * 2. Add maatching button with ID: {base-id}-btn
 * 3. Then this'll auto-discover & wire up all modals on page load
 * 
 * - Derives button ID by replacing '-modal' with '-btn'
 * - Sets up open/close/submit handlers
 * - Gets endpoint from modal's data-endpoint attribute
 */


// Scan for modals following our naming pattern
const modals = document.querySelectorAll('[id$="-modal"]'); // $= means "ends with"

modals.forEach(modal => {
    const fullId = modal.id; // "habit-entry-dashboard-modal"
    const baseId = fullId.replace('-modal', ''); // "habit-entry-dashboard"
    const button = document.querySelector(`#${baseId}-btn`);

    if (button) {
        // set up this modal
        const buttonId = button.id;
        const endpoint = window.location.origin + modal.dataset.endpoint; // dialog's data-endpoint
        setupModal(fullId, buttonId, endpoint);
    }

    // Set up tabbed modal handling based on naming conventions
    if (modal.classList.contains('tabbed-modal') || modal.querySelector('.tabs')) {
        setupTabbedModal(modal);
    }
});

function setupModal(modalId, buttonId, endpoint) {
    const modal = document.querySelector(`#${modalId}`);
    if (!modal) return;

    document.addEventListener('click', (e) => {
        if (e.target.matches(`#${buttonId}`)) {
            modal.showModal();
        }
        else if (e.target.matches(`#${modalId}-close-btn`)) {
            modal.querySelector('form').reset();
            modal.close();
        }
    });

    modal.addEventListener('cancel', () => {
        modal.querySelector('form')?.reset();
    });

    modal.addEventListener('submit', async (e) => {
        const form = e.target;

        // Skip interception if the form opts out
        if (form.hasAttribute('data-noajax')) {
            return;
        }

        e.preventDefault();

        const formData = new FormData(form);
        apiRequest('POST', endpoint, (responseData) => { // get server response inside success callback
            makeTableRow(responseData.data);
            makeToast(responseData.message, 'success');
        }, formData);

        form.reset();
        modal.close();
    });
}

function setupTabbedModal(modal) {
    modal.querySelectorAll('.tabs button').forEach(btn => {
        btn.addEventListener('click', () => {
            // hide all panels & remove active
            document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(p => p.hidden = true);
            // show selected
            const tabId = 'tab-' + btn.dataset.tab;
            const panel = document.querySelector(`#${tabId}`);
            if (panel) {
                btn.classList.add('active');
                panel.hidden = false;
            };
        });
    });

    // Auto-activate first tab
    const firstTab = modal.querySelector('.tabs button');
    firstTab?.click();
}

// Trying out a confirmation manager singleton for dynamically handling confirmation popups
// TODO: Practice/study further
export const confirmationManager = {
    currentResolve: null, // store active resolve function

    init() {
        // one-time setup for confirmation modals
        const modal = document.querySelector('#confirmation-modal');
        modal?.addEventListener('click', (e) => {
            if (e.target.matches('#confirm-ok') && this.currentResolve) {
                this.currentResolve(true); // lets our await receive its answer
                modal.close();
                this.currentResolve = null; // then clean it up quickly prior to subsequent calls
            }
            else if (e.target.matches('#confirm-cancel') && this.currentResolve) {
                this.currentResolve(false);
                modal.close();
                this.currentResolve = null;
            }
        })
    },

    show(message) {
        return new Promise((resolve) => {
            // 1. update modal text (cls: confirmation-message) with message
            const confirmationMsg = document.querySelector('.confirmation-message');
            confirmationMsg.textContent = message;

            // 2. Show the modal
            const modal = document.querySelector('#confirmation-modal');
            modal?.showModal();

            this.currentResolve = resolve; // store THIS promise's resolve
        });
    }
}

// Set up listeners once
confirmationManager.init();