# Uses existing container name & credentials
# Keeps current dbs we already have set up
services:
  db:
    image: postgres:17.4
    container_name: vesper-db-prod
    # ports:
      # - "5432:5432" <= Doing this on our DB publishes the DB to the host
    # Keep db service internally accessible to other services only
    # Use 'expose' to document port
    expose:
      - "5432"
    env_file: # only puts vars inside the container at runtime - does not provide vals for Compose's variable substitution
    # Default behavior is reads .env, hence why using ${DB_USER} worked before. When specifying env_file, tho, that goes out the window, and substitutions become pointless?
      - prod.env
    # environment:
    #   POSTGRES_USER: ${DB_USER}
    #   POSTGRES_PASSWORD: ${DB_PASSWORD}
    #   POSTGRES_DB: ${DB_NAME}
    volumes:
      - pgdata-prod:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro # :ro is read-only, which is good practice for init scripts
    healthcheck:
      # The actual command to run inside the container
      test: ["CMD-SHELL", "pg_isready -U \"$POSTGRES_USER\" -d \"$POSTGRES_DB\" -h 127.0.0.1"] # returns 'accepting connections' if up
      interval: 30s     # How often to run the health check (default: 30s)
      timeout: 5s       # Max time to wait for the command to finish (default: 30s)
      # start-period: 10s # Grace period after container starts before failures count (default: 0s)
      retries: 3        # Allowed consecutive failures before marking unhealthy (default: 3)
    restart: always
    # TODO: NOTES: Docker keeps container logs in JSON files. Without rotation, they can grow forever?
    logging:
      driver: json-file
      # This keep ~30MB max per service (3 files * 10MB)
      options:
        max-size: "10m"
        max-file: "3"

  # Service for Flask app
  web:
    build:
      context: .
      dockerfile: Dockerfile
    depends_on:
      - db
    env_file:
      - prod.env
    # environment:
      # APP_ENV: prod
      # DATABASE_URI: ${DATABASE_URI}
      # SECRET_KEY: ${SECRET_KEY}
      # OPENWEATHER_API_KEY: ${OPENWEATHER_API_KEY}
    ports:
      - "5000:5000"
    healthcheck:
      # Point curl to our devtools /health route & fail fast
      # TODO: NOTES: Study these flags a bit
      test: ["CMD", "curl", "-fsS", "-m", "2", "http://localhost:5000/health"]
      interval: 30s
      timeout: 5s
      # start-period: 10s
      retries: 3
    restart: always
    # TODO: NOTES: Docker keeps container logs in JSON files. Without rotation, they can grow forever?
    logging:
      driver: json-file
      # This keep ~30MB max per service (3 files * 10MB)
      options:
        max-size: "10m"
        max-file: "3"


volumes:
  pgdata-prod:
    name: vesper-pgdata-prod