diff --git a/app/_templates/_partials/_ui.html b/app/_templates/_partials/_ui.html
index acd715d..5c9360d 100644
--- a/app/_templates/_partials/_ui.html
+++ b/app/_templates/_partials/_ui.html
@@ -30,7 +30,9 @@ If we're defining reusable COMPONENTS (with structure/behavior/logic) â†’ here (
         <tr class="table-row" data-item-id="{{ item.id }}" data-module="{{ module_name }}" data-subtype="{{ subtype }}">
           {{ caller(item, headers) }}
           <td class="table-cell delete-cell">
-            {{ delete_btn() }}
+            <button class="row-actions dots-btn btn-icon btn-square" data-item-id="{{ item.id }}">
+                ooo
+            </button>
           </td>
         </tr>
       {% endfor %}
diff --git a/app/modules/api/crud_routes.py b/app/modules/api/crud_routes.py
index 9d2c7d4..faa1166 100644
--- a/app/modules/api/crud_routes.py
+++ b/app/modules/api/crud_routes.py
@@ -12,6 +12,8 @@ from app.modules.metrics.models import DailyEntry
 from app.modules.tasks.models import Task
 from app.modules.time_tracking.models import TimeEntry
 from app.shared.database.helpers import safe_delete
+from app.shared.datetime.helpers import convert_to_timezone
+
 
 crud_bp = Blueprint("crud", __name__)
 
@@ -37,7 +39,7 @@ MODEL_CLASSES = {
 def get_model_class(module, subtype: str):
     return MODEL_CLASSES.get((module, subtype))
 
-@crud_bp.route("/<module>/<subtype>/<int:item_id>", methods=["PATCH", "DELETE"])
+@crud_bp.route("/<module>/<subtype>/<int:item_id>", methods=["GET", "PATCH", "DELETE"])
 @login_required
 @with_db_session
 def item(session, module, subtype, item_id):
@@ -54,6 +56,15 @@ def item(session, module, subtype, item_id):
     # Ownership check
     check_item_ownership(item, current_user.id)
     
+    if request.method == 'GET':
+        item_dict = item.to_dict()
+
+        # Convert dt fields to user's timezone first
+        if item_dict.get("due_date"):
+            item_dict["due_date"] = convert_to_timezone(item_dict["due_date"], current_user.timezone).isoformat()
+
+        return api_response(True, "Item retrieved", data=item_dict), 200
+
     if request.method == 'PATCH':
         data = request.get_json()
         for field, value in data.items():
diff --git a/app/modules/tasks/routes.py b/app/modules/tasks/routes.py
index cca8fda..53c348e 100644
--- a/app/modules/tasks/routes.py
+++ b/app/modules/tasks/routes.py
@@ -32,10 +32,10 @@ def dashboard(session):
 
 
 @tasks_bp.route("/", methods=["GET", "POST"])
+@tasks_bp.route("/<int:task_id>", methods=["PATCH"])
 @login_required
 @with_db_session
-def tasks(session):
-    if request.method == "POST":
+def tasks(session, task_id=None):
 
         parsed_data = parse_task_form_data(request.form.to_dict())
 
@@ -45,7 +45,8 @@ def tasks(session):
 
         tasks_repo = TasksRepository(session, current_user.id, current_user.timezone)
         tasks_service = TasksService(tasks_repo, current_user.timezone)
-        result = tasks_service.create_task(typed_data)
+
+        result = tasks_service.create_task(typed_data, task_id) # None -> POST, else -> PATCH
 
         if not result["success"]:
             return api_response(False, result["message"], errors=result["errors"])
diff --git a/app/modules/tasks/service.py b/app/modules/tasks/service.py
index e7c09d2..0932a65 100644
--- a/app/modules/tasks/service.py
+++ b/app/modules/tasks/service.py
@@ -12,30 +12,44 @@ class TasksService:
         self.user_tz = user_tz
 
 
-    def create_task(self, data: dict):
+    def create_task(self, data: dict, task_id: int | None = None):
 
         # Attach due_date datetime
         data["due_date"] = self.to_eod_datetime(data.get("due_date"), self.user_tz)
 
-        # Check for existing frog task
-        if data["is_frog"]:
-            start_utc, end_utc = day_range_utc(data["due_date"].date(), self.user_tz)
-
-            existing_frog = self.repo.get_frog_task_in_window(start_utc, end_utc)
-            if existing_frog:
-                return service_response(
-                    False,
-                    "Error: Duplicate frog task",
-                    errors={"frog_task": [f"You already have a 'frog' task for {data["due_date"].date().isoformat()}"]}
-                )
-
-        task = self.repo.create_task(
-            name=data["name"],
-            priority=data.get("priority"),
-            due_date=data.get("due_date"),
-            is_frog=data["is_frog"]
-        )
-        return service_response(True, "Task added", data={"task": task})
+        ### UPDATE
+        if task_id:
+            task = self.repo.get_task_by_id(task_id)
+            if not task:
+                return service_response(False, "Task not found")
+            
+            # Update fields
+            for field, value in data.items():
+                setattr(task, field, value)
+            
+            return service_response(True, "Task updated", data={"task": task})
+
+        else:
+            ### CREATE
+            # Check for existing frog task
+            if data["is_frog"]:
+                start_utc, end_utc = day_range_utc(data["due_date"].date(), self.user_tz)
+
+                existing_frog = self.repo.get_frog_task_in_window(start_utc, end_utc)
+                if existing_frog:
+                    return service_response(
+                        False,
+                        "Error: Duplicate frog task",
+                        errors={"frog_task": [f"You already have a 'frog' task for {data["due_date"].date().isoformat()}"]}
+                    )
+
+            task = self.repo.create_task(
+                name=data["name"],
+                priority=data.get("priority"),
+                due_date=data.get("due_date"),
+                is_frog=data["is_frog"]
+            )
+            return service_response(True, "Task added", data={"task": task})
 
 
     def to_eod_datetime(self, date: date | None, tz_str: str) -> datetime | None:
diff --git a/app/static_src/css/components.css b/app/static_src/css/components.css
index 4d3b29e..e96d9fb 100644
--- a/app/static_src/css/components.css
+++ b/app/static_src/css/components.css
@@ -273,10 +273,10 @@ input, select, textarea {
 .table-row {
     transition: background-color 25ms ease-out;
 }
-.table-row .delete-btn {
+.table-row .row-actions {
     visibility: hidden; /* All (table) delete buttons start hidden */
 }
-.table-row:hover .delete-btn {
+.table-row:hover .row-actions {
     visibility: visible; /* ..and become visible on hover of row */
 }
 .table-row:nth-child(even) {
diff --git a/app/static_src/js/shared/ui/context-menu.js b/app/static_src/js/shared/ui/context-menu.js
index 796fa45..8bbc00e 100644
--- a/app/static_src/js/shared/ui/context-menu.js
+++ b/app/static_src/js/shared/ui/context-menu.js
@@ -4,65 +4,93 @@ import { apiRequest } from '../services/api.js';
 const menuItems = ['Edit', 'Delete'];
 const menuItemsGroceries = ['Add to shopping list'];
 
-// TODO: Properly implement & wire into tables.js functionalities
-function createContextMenu(e) {
-    const row = e.target.closest('.table-row');
-    if (!row) return;
-
-    // Accessing OR making our custom context menu
-    let menu = document.querySelector('.context-menu');
-    if (!menu) {
-        menu = document.createElement('ul');
-
-        // Start with copy of the base items
-        // spread operator here [...menuItems] makes a shallow copy
-        let items = [...menuItems];
-
-        // If clicked row is from the Transactions table, extend the list
-        // Append our shopping list option if it's the transactions table
-        // so: items = ['Edit', 'Delete', 'Add to shopping list']
-        if (row.dataset.subtype === 'transaction' || row.dataset.subtype === 'product') {
-            items = [...items, ...menuItemsGroceries];
-        }
-    
-        // Now we map over 'items' to render <li> elements
-        const menuElements = items.map(label => {
-            const li = document.createElement('li');
-            li.textContent = label;
-            return li;
-        });
-        menuElements.forEach(element => menu.appendChild(element));
-        menu.classList.add('context-menu');
+/**
+ * 
+ * @param {string} type - Type of menu to open. Determines which actions array to use, how to position (cursor vs rect)
+ * @param {object} triggerInfo - Object containing relevant positioning + data context needed, bound to menu itself before finishing
+ * @returns 
+ */
+function openMenu(type, triggerInfo) {
+    document.querySelector('.context-menu')?.remove(); // Always remove any menus before opening a new one to ensure clean slate
+
+    const menu = document.createElement('ul');
+    menu.classList.add(`context-menu`);
+
+    // Shallow copy of menuItems using spread operator: [...menuItems]
+    let items = [...menuItems];
+
+    // Append our shopping list option if it's the transactions table
+    // so: items = ['Edit', 'Delete', 'Add to shopping list']
+    if (triggerInfo.context.subtype === 'transaction' || triggerInfo.context.subtype === 'product') {
+        items = [...items, ...menuItemsGroceries];
     }
 
-    // Position menu at cursor
-    menu.style.left = e.clientX + 'px';
-    menu.style.top = e.clientY + 'px';
-    menu.style.display = 'block';
+    // Now we map over 'items' to render <li> elements
+    const menuElements = items.map(label => {
+        const li = document.createElement('li');
+        li.textContent = label;
+        return li;
+    });
+
+    menuElements.forEach(element => menu.appendChild(element));
 
-    // Bind data to menu for retrieval elsewhere without relying on DOM traversal + relationships
-    menu.context = {
-        itemId: row.dataset.itemId,
-        name: row.querySelector('td:nth-child(2)').textContent,
-        subtype: row.dataset.subtype
+    // Position menu either at cursor (type context) OR button (type dots)
+    if (type === 'context') {
+        menu.style.left = triggerInfo.x + 'px';
+        menu.style.top = triggerInfo.y + 'px';
     }
+    else if (type === 'dots') {
+        const { left, top } = triggerInfo.rect;
+        menu.style.left = `${left}px`;
+        menu.style.top  = `${top}px`;
+    }
+
+    menu.style.display = 'block';
+    menu.context = triggerInfo.context; // bind context info to menu itself
+
     document.body.appendChild(menu);
 }
 
 document.addEventListener('contextmenu', (e) => {
     if (e.ctrlKey) {
         e.preventDefault();
-        createContextMenu(e); // TODO?: Pull our context menu handling into some kind of global.js
+
+        const row = e.target.closest('.table-row');
+        if (!row) return;
+
+        const triggerInfo =
+        {
+            x: e.clientX,
+            y: e.clientY,
+            context: {
+                itemId: row.dataset.itemId,
+                name: row.querySelector('td:nth-child(2)').textContent,
+                module: row.dataset.module,
+                subtype: row.dataset.subtype
+            }
+        };
+
+        openMenu('context', triggerInfo); // TODO?: Pull our context menu handling into some kind of global.js
+    }
+});
+
+document.addEventListener('keydown', (e) => {
+    if (e.key === 'Escape') {
+        document.querySelector('.context-menu')?.remove();
     }
 });
 
 document.addEventListener('click', async (e) => {
     const menu = document.querySelector('.context-menu');
 
+    if (menu && !menu.contains(e.target)) {
+        menu?.remove();
+        return;
+    }
+
     // TODO: Should rewrite this to separate concerns but have got to stop committing to rewrites for now
     if (e.target.textContent === 'Add to shopping list') {
-        const productId = menu.context.itemId;
-        const productName = menu.context.name;
+        const { productId, productName } = menu.context;
         const quantity = 1;
         menu?.remove();
 
@@ -81,8 +109,71 @@ document.addEventListener('click', async (e) => {
         }, data);
     }
 
-    else if (!e.target.matches('.context-menu')) {
-        menu?.remove();
+    // SCRATCH WORK
+    if (e.target.matches('.dots-btn')) {
+        const button = e.target.closest('.row-actions');
+        const row = e.target.closest('.table-row');
+        const triggerInfo =
+        {
+            rect: button.getBoundingClientRect(),
+            context: {
+                itemId: row.dataset.itemId,
+                name: row.querySelector('td:nth-child(2)').textContent,
+                module: row.dataset.module,
+                subtype: row.dataset.subtype
+            }
+        };
+
+        openMenu('dots', triggerInfo);
+    }
+    if (e.target.textContent === 'Delete') {
+        const { itemId, module, subtype } = menu.context;
+        const url = `/${module}/${subtype}/${itemId}`;
+
+        apiRequest('DELETE', url, (responseData) => {
+            console.log(`Deleted item: ${responseData.data.name}`);
+        });
+    }
+    // Prototype - refine/delete
+    if (e.target.textContent === 'Edit') {
+        const { itemId, module, subtype } = menu.context;
+
+        const url = `/${module}/${subtype}/${itemId}`;
+
+        apiRequest('GET', url, (responseData) => {
+            console.log(responseData.data.name);
+
+            // Grab our modal (tasks first here) & pre-fill name input
+            const modal = document.querySelector('#task-entry-dashboard-modal');
+            modal.dataset.mode = 'edit'; // to direct submits to PATCH instead of POST
+            modal.dataset.itemId = responseData.data.id;
+            modal.dataset.subtype = subtype;
+            modal.showModal();
+
+            // Use Object.entries(..) to take the responseData object and make it iterable
+            // Then forEach to loop through each entry, using [fieldName, fieldValue] here to
+            // destructure each entry into its key-value parts
+            // Inside the loop body (predicate?) we can select the current input since the IDs align with the to_dict key names
+            // 
+            console.log(responseData.data)
+            Object.entries(responseData.data).forEach(([fieldName, fieldValue]) => {
+                const currentInput = modal.querySelector(`#${fieldName}`);
+                if (currentInput) {
+                    if (fieldValue == null) {
+                        return; // skip null/undefined fields to leave them empty
+                    }
+                    if (currentInput.type === 'checkbox') {
+                        currentInput.checked = fieldValue;
+                    } else if (currentInput.type === 'date') {
+                        currentInput.value = fieldValue.slice(0, 10);
+                    } else if (currentInput.type === 'select-one') {
+                        currentInput.value = fieldValue.toLowerCase();
+                    } else {
+                        currentInput.value = fieldValue;
+                    }
+                }
+            });
+        })
     }
 });
 
diff --git a/app/static_src/js/shared/ui/modal-manager.js b/app/static_src/js/shared/ui/modal-manager.js
index 0d0b43c..eabb398 100644
--- a/app/static_src/js/shared/ui/modal-manager.js
+++ b/app/static_src/js/shared/ui/modal-manager.js
@@ -71,11 +71,21 @@ function setupModal(modalId, buttonId, endpoint) {
         e.preventDefault();
 
         const formData = new FormData(form);
-        apiRequest('POST', endpoint, (responseData) => { // get server response inside success callback
-            makeTableRow(responseData.data);
-            makeToast(responseData.message, 'success');
-        }, formData);
-
+        
+        // PATCH
+        if (modal.dataset.mode === 'edit') {
+            const url = `${endpoint}/${modal.dataset.itemId}`;
+            apiRequest('PATCH', url, (responseData) => {
+                makeToast(responseData.message, 'success');
+            }, formData);
+        }
+        // POST
+        else {
+            apiRequest('POST', endpoint, (responseData) => { // get server response inside success callback
+                makeTableRow(responseData.data);
+                makeToast(responseData.message, 'success');
+            }, formData);
+        }
         form.reset();
         modal.close();
     });
